#AUTOGENERATED! DO NOT EDIT! File to edit: dev/60b_medical_imaging.ipynb (unless otherwise specified).

__all__ = ['dicom_tags', 'dicom_modality', 'modality', 'NotStructTypeException', 'roi_names', 'poly2mask']

#Cell
from ..test import *
from ..basics import *
# from local.vision.all import *

from .imaging import *

#Cell
dicom_tags = types.SimpleNamespace(
    # common
    modality = (0x0008,0x0060),
    study_instance_uid = (0x0020, 0x000d),
    sop_instance_uid = (0x0008, 0x0018),


    # MR pixel array conversion
    window_center = (0x0028, 0x1050),
    window_width = (0x0028, 0x1051),

    # for contour data mapping and extraction
    roi_structure_sequence = (0x3006,0x0020),
    roi_contour_sequence = (0x3006, 0x0039),
    roi_number = (0x3006,0x0022),
    roi_name = (0x3006, 0x0026),
    referenced_roi_number = (0x3006, 0x0084),
    contour_sequence = (0x3006, 0x0040),
    contour_image_sequence = (0x3006, 0x0016),
    contour_frame_refid = (0x0008, 0x1155),
    contour_data = (0x3006, 0x0050),

    # contour to pixel position conversion
    pixel_spacing = (0x0028,0x0030),
    image_orientation = (0x0020,0x0037),
    image_position = (0x0020,0x0032),
    slice_thickness = (0x0018, 0x0050),
    slice_location = (0x0020,0x1041),
    anatomical_orientation = (0x0010,0x2210)
)

dicom_modality = types.SimpleNamespace(
    # can be extended
    ct = "CT",
    mr = "MR",
    rtstruct = "RTSTRUCT"
)

#Cell
@patch_property
def modality(self:DcmDataset):
    return self[dicom_tags.modality].value

#Cell
class NotStructTypeException(Exception):
    def __init__(self, modality): self.modality = modality
    def __str__(self): return f"This method or property is only available for RTSTRUCT types, not for {self.modality}"

#Cell
@patch_property
def roi_names(self:DcmDataset):
    "return available ROI names for RTSTRUCT type DcmDatasets"
    if self.modality == dicom_modality.rtstruct:
        return {o[dicom_tags.roi_name].value for o in self[dicom_tags.roi_structure_sequence]}
    else: raise NotStructTypeException(self.modality)

#Cell
@patch
def contour_sequence(self:DcmDataset, roi_name):
    "return contour sequence for a given ROI by name"
    if self.modality == dicom_modality.rtstruct:
        for o in self[dicom_tags.roi_structure_sequence]:
            if o[dicom_tags.roi_name].value == roi_name:
                roi_number = o[dicom_tags.roi_number].value
        for o in self[dicom_tags.roi_contour_sequence]:
            if o[dicom_tags.referenced_roi_number].value == roi_number:
                return o[dicom_tags.contour_sequence]
    else: raise NotStructTypeException(self.modality)

#Cell
@patch
def contour_refdict(self:DcmDataset, roi_name):
    "get dict of referenence frame id to x,y,z (mm) contour for a given ROI"
    if self.modality == dicom_modality.rtstruct:
        roi_contour_seq = self.contour_sequence(roi_name)
        d = defaultdict(list)
        for contour_ds in roi_contour_seq:
            contour_data = contour_ds[dicom_tags.contour_data].value
            contour_img_sequence = list(contour_ds[dicom_tags.contour_image_sequence])
            try: assert len(contour_img_sequence) == 1
            except: raise Exception("""Contour Image Sequence doesn't have exactly one element,
                                    might have more instance references.""")
            refid = contour_img_sequence[0][dicom_tags.contour_frame_refid].value
            d[refid].append(contour_data)
        return d
    else: raise NotStructTypeException(self.modality)

#Cell
from skimage import draw
def poly2mask(i, j, shape):
    "convert polygon coordinates to closed planar mask, can be floating vertices"
    row_coords, col_coords = draw.polygon(j, i, shape)
    mask = np.zeros(shape, dtype=np.int)
    mask[row_coords, col_coords] = 1
    return mask

#Cell
@patch
def contourdata2mask(self:DcmDataset, contourdata:DcmMultiValue):
    "A method for reference DcmDataset to convert real world x,y,z (mm) contour to pixel mask"
    pixel_spacing = array(self[dicom_tags.pixel_spacing].value)
    image_position = array(self[dicom_tags.image_position].value)
    cntdata = array(contourdata).reshape(-1,3)
    i,j = list(zip(*(cntdata[:,:2] - image_position[:2]) / (pixel_spacing)))
    return poly2mask(i,j,self.shape)